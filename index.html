<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Classic Snake Game with AI</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        /* General Reset and Font */
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #0d1117; /* Dark background - KEEP BLACK */
            font-family: 'Press Start 2P', monospace;
            color: #d8dee9; /* Light text color */
            overflow: auto; /* Allow scrolling if content is too large */
            touch-action: none; /* Prevents default browser touch actions on the whole body */
        }

        .main-wrapper {
            display: flex;
            flex-direction: row; /* Default side-by-side on desktop */
            gap: 40px;
            padding: 20px;
            align-items: flex-start; /* Align content to the top of the container */
            max-width: 1200px;
            width: 100%;
        }

        .game-column, .leaderboard-column {
            flex-grow: 1;
            flex-basis: 0;
            min-width: 300px; /* Ensure minimum width for readability */
        }

        .game-column {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            background: #161b22; /* Very dark container background */
            border: 8px solid #555555; 
            box-shadow: 0 0 40px rgba(255, 0, 119, 0.4), inset 0 0 20px rgba(255, 0, 119, 0.2);
            border-radius: 15px;
            position: relative;
        }

        h1 {
            font-size: 1.5rem;
            margin-bottom: 20px;
            color: #ff0077; 
            text-shadow: 0 0 5px #ff0077;
        }

        #gameCanvas {
            border: 4px solid #ff0077;
            background-color: #0d1117;
            box-shadow: 0 0 15px rgba(255, 0, 119, 0.8);
            max-width: 100%; /* Important for responsiveness */
            height: auto;
            aspect-ratio: 1 / 1;
            touch-action: none; /* CRITICAL for preventing double-tap zoom/scroll */ 
        }

        .controls {
            display: flex;
            justify-content: space-around;
            width: 100%;
            margin-top: 20px;
            user-select: none;
        }

        .score-panel {
            font-size: 0.8rem;
            margin-bottom: 10px;
            text-align: center;
            width: 100%;
        }
        
        .score-value {
            color: #ff0077; 
        }

        .message-box {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95); /* Slightly darker for modal */
            display: none; 
            flex-direction: column;
            justify-content: center;
            align-items: center;
            border-radius: 10px;
            z-index: 100;
            text-align: center;
            padding: 20px;
            box-sizing: border-box;
        }
        
        .message-box p {
            font-size: 1.2rem; 
            margin: 10px 0;
            color: #ffffff; 
            text-shadow: 0 0 10px #ffffff;
        }
        
        .message-box .game-over-text {
            font-size: 1.5rem;
        }

        .name-input-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 15px;
        }

        #playerNameInput {
            font-family: 'Press Start 2P', monospace;
            padding: 8px;
            margin-bottom: 10px;
            border: 2px solid #ff0077;
            background-color: #0d1117;
            color: #ffffff;
            font-size: 0.7rem;
            text-align: center;
            width: 150px;
            border-radius: 5px;
        }


        .control-button {
            background-color: #ff0077;
            color: #ffffff;
            border: none;
            padding: 15px 20px;
            margin: 5px;
            text-transform: uppercase;
            font-size: 0.7rem;
            font-weight: bold;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 4px #990047;
            transition: all 0.1s;
            touch-action: manipulation; /* Optimizes for touch response */
        }

        .control-button:active {
            box-shadow: 0 0 #990047;
            transform: translateY(4px);
        }

        /* Leaderboard Styling */
        #leaderboard {
            background: #161b22;
            border: 4px solid #ff0077;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 0 15px rgba(255, 0, 119, 0.5);
            max-width: 400px;
            width: 100%;
            min-height: 400px;
            margin: 0 auto;
        }

        #leaderboard h2 {
            text-align: center;
            font-size: 1rem;
            color: #ffffff;
            text-shadow: 0 0 5px #ff0077;
            margin-bottom: 20px;
            border-bottom: 2px solid #ff0077;
            padding-bottom: 10px;
        }
        
        .leaderboard-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .leaderboard-list li {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px dashed #555555;
            font-size: 0.7rem;
        }
        
        .leaderboard-list li:last-child {
            border-bottom: none;
        }

        .leaderboard-list .rank {
            color: #ff0077;
            width: 10%;
            text-align: left;
        }
        .leaderboard-list .name {
            color: #ffffff;
            width: 60%;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
        }
        .leaderboard-list .score {
            color: #ff0077;
            width: 30%;
            text-align: right;
        }
        .leaderboard-list li:first-child .rank,
        .leaderboard-list li:first-child .score {
            font-size: 0.85rem;
            text-shadow: 0 0 5px #ff0077;
        }


        /* Responsive adjustments for smaller screens */
        @media (max-width: 800px) {
            .main-wrapper {
                flex-direction: column;
                gap: 20px;
                align-items: center;
            }
            .game-container {
                width: 90vw; 
                max-width: 400px;
            }
            /* .leaderboard-column will be controlled by JS for mobile */
        }
    </style>
</head>
<body>

<div class="main-wrapper">
    <!-- LEADERBOARD COLUMN -->
    <div class="leaderboard-column" id="leaderboardColumn">
        <div id="leaderboard">
            <h2>TOP 10 SCORES</h2>
            <ul id="leaderboardList" class="leaderboard-list">
                <!-- Scores will be injected here -->
                <li style="justify-content:center;">Loading scores...</li>
            </ul>
        </div>
        <p style="font-size: 0.5rem; text-align: center; margin-top: 10px; color: #555;">User ID: <span id="displayUserId">...</span></p>
    </div>

    <!-- GAME COLUMN -->
    <div class="game-column">
        <div class="game-container">
            <h1>SNAKE ARCADE</h1>

            <div class="score-panel">
                SCORE: <span id="scoreValue" class="score-value">0</span>
            </div>

            <!-- Canvas is now touch-enabled for swipes -->
            <canvas id="gameCanvas" width="400" height="400"></canvas>

            <div class="controls">
                <!-- Directional controls for mobile/touch users (kept for D-Pad style tapping) -->
                <button class="control-button" data-direction="up">Up</button>
                <button class="control-button" data-direction="left">Left</button>
                <button class="control-button" data-direction="right">Right</button>
                <button class="control-button" data-direction="down">Down</button>
            </div>

            <!-- Message Box/Modal -->
            <div id="messageBox" class="message-box">
                <p id="messageText" class="game-over-text">GAME OVER!</p>
                <p id="finalScoreDisplay">Final Score: <span id="finalScore">0</span></p>
                
                <div id="nameInputGroup" class="name-input-group">
                    <p style="font-size: 0.6rem; margin-bottom: 5px;">Enter Name to Save Score:</p>
                    <input type="text" id="playerNameInput" maxlength="10" placeholder="Max 10 Chars">
                </div>

                <button id="restartButton" class="control-button">Start Game</button>
            </div>
        </div>
    </div>
</div>

<script type="module">
    // --- FIREBASE IMPORTS ---
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, addDoc, onSnapshot, collection, query, limit, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    // --- DOM ELEMENTS ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreValue = document.getElementById('scoreValue');
    const messageBox = document.getElementById('messageBox');
    const messageText = document.getElementById('messageText');
    const finalScore = document.getElementById('finalScore');
    const finalScoreDisplay = document.getElementById('finalScoreDisplay');
    const restartButton = document.getElementById('restartButton');
    const controls = document.querySelector('.controls');
    const leaderboardList = document.getElementById('leaderboardList');
    const playerNameInput = document.getElementById('playerNameInput');
    const nameInputGroup = document.getElementById('nameInputGroup');
    const displayUserId = document.getElementById('displayUserId');
    const leaderboardColumn = document.getElementById('leaderboardColumn'); // NEW: Get the leaderboard container

    // --- GAME CONSTANTS AND STATE ---
    const TILE_COUNT = 20;
    const INITIAL_SPEED = 150; 
    const SPEED_INCREMENT = 5; 
    const MAX_SPEED_CAP_SCORE = 15; 
    const APPLES_REQUIRED_FOR_WIN = 100; 

    // Difficulty thresholds (based on score/apples)
    const OBSTACLE_THRESHOLD_1 = 20;
    const OBSTACLE_THRESHOLD_2 = 50;
    const ENEMY_SNAKE_THRESHOLD = 50;
    const OBSTACLE_COUNT_1 = 5;
    const OBSTACLE_COUNT_2 = 10;
    const MAX_ENEMY_SNAKES = 3; 
    const ENEMY_AI_MOVE_CHANCE = 0.7; 

    let tileSize; 
    let playerSnake = [];
    let playerVelocity = { x: 0, y: 0 };
    let food = { x: 10, y: 5 };
    let blackHole = null; 
    let obstacles = []; 
    let enemySnakes = []; 
    let score = 0;
    let gameSpeed = INITIAL_SPEED; 
    let gameInterval;
    let lastPlayerDirection = { x: 0, y: 0 }; 
    let isGameStarted = false; 
    let isGameOver = false;
    
    // --- TOUCH/SWIPE STATE ---
    let touchStartX = 0;
    let touchStartY = 0;
    const SWIPE_THRESHOLD = 50; 

    // --- FIREBASE STATE ---
    let db;
    let auth;
    let userId = null;
    let appId;

    // --- FIREBASE SETUP AND LEADERBOARD LOGIC (Unchanged) ---
    async function setupFirebase() {
        if (typeof __firebase_config === 'undefined' || typeof __app_id === 'undefined') {
            console.error("Firebase config or app ID is missing. Leaderboard disabled.");
            return;
        }

        appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = JSON.parse(__firebase_config);

        const app = initializeApp(firebaseConfig);
        db = getFirestore(app);
        auth = getAuth(app);
        
        try {
            if (typeof __initial_auth_token !== 'undefined') {
                await signInWithCustomToken(auth, __initial_auth_token);
            } else {
                await signInAnonymously(auth);
            }
        } catch (error) {
            console.error("Firebase Auth failed:", error);
        }

        onAuthStateChanged(auth, (user) => {
            if (user) {
                userId = user.uid;
                displayUserId.textContent = userId;
                setupLeaderboardListener();
            } else {
                userId = 'unauthenticated_' + Math.random().toString(36).substring(2, 9);
                displayUserId.textContent = 'Auth Failed';
            }
        });
    }

    async function saveScore(name, finalScore) {
        if (!db || finalScore === 0) return;
        const leaderboardRef = collection(db, `artifacts/${appId}/public/data/leaderboard`);
        
        try {
            await addDoc(leaderboardRef, {
                name: name.trim() || "ANONYMOUS",
                score: finalScore,
                userId: userId,
                createdAt: serverTimestamp()
            });
            console.log("Score saved successfully!");
        } catch (e) {
            console.error("Error adding document: ", e);
        }
    }

    function updateLeaderboardUI(scores) {
        leaderboardList.innerHTML = '';
        if (scores.length === 0) {
            leaderboardList.innerHTML = '<li style="justify-content:center;">No scores yet!</li>';
            return;
        }

        scores.forEach((item, index) => {
            const listItem = document.createElement('li');
            listItem.innerHTML = `
                <span class="rank">${index + 1}.</span>
                <span class="name">${item.name}</span>
                <span class="score">${item.score}</span>
            `;
            leaderboardList.appendChild(listItem);
        });
    }

    function setupLeaderboardListener() {
        if (!db) return;
        const leaderboardRef = collection(db, `artifacts/${appId}/public/data/leaderboard`);
        const q = query(leaderboardRef, limit(20)); 

        onSnapshot(q, (snapshot) => {
            let scores = [];
            snapshot.forEach((doc) => {
                const data = doc.data();
                if (typeof data.score === 'number' && data.name) {
                    scores.push({ id: doc.id, name: data.name, score: data.score });
                }
            });
            scores.sort((a, b) => b.score - a.score);
            updateLeaderboardUI(scores.slice(0, 10));
        }, (error) => {
            console.error("Leaderboard snapshot error:", error);
            leaderboardList.innerHTML = '<li style="justify-content:center; color: #ff0077;">Error loading scores.</li>';
        });
    }
    
    // NEW: Function to toggle leaderboard visibility based on screen size
    function toggleLeaderboardVisibility(show) {
        if (window.innerWidth <= 800) {
            leaderboardColumn.style.display = show ? 'flex' : 'none';
        } else {
            // Always show on desktop
            leaderboardColumn.style.display = 'flex';
        }
    }


    // --- GAME INITIALIZATION AND STATE RESET ---

    function initializeGame() {
        tileSize = canvas.width / TILE_COUNT;
        
        // Reset ALL state variables
        playerSnake = [{ x: 10, y: 10 }]; 
        playerVelocity = { x: 0, y: 0 };
        lastPlayerDirection = { x: 0, y: 0 };
        score = 0;
        gameSpeed = INITIAL_SPEED;
        blackHole = null;
        obstacles = [];
        enemySnakes = [];
        isGameStarted = false; 
        isGameOver = false;
        
        scoreValue.textContent = 0;
        finalScore.textContent = 0;
        
        nameInputGroup.style.display = 'none';
        finalScoreDisplay.style.display = 'none'; 
        restartButton.textContent = 'Start Game';

        messageText.textContent = 'Welcome to SNAKE ARCADE! Swipe or use arrows to move.';
        messageText.classList.remove('game-over-text');
        messageBox.style.display = 'flex';
        
        // NEW: Hide leaderboard on initialization if on mobile
        toggleLeaderboardVisibility(false);

        placeFood();
        
        clearInterval(gameInterval);
        gameInterval = setInterval(gameLoop, gameSpeed);
        
        draw(); 
        window.focus(); 
    }

    // --- CORE GAME OBJECT PLACEMENT AND COLLISION CHECKING ---

    function isPlayerSnakeCollision(point) {
        return playerSnake.some(segment => segment.x === point.x && segment.y === point.y);
    }
    
    function isObstacleCollision(point) {
        return obstacles.some(obs => obs.x === point.x && obs.y === point.y);
    }

    function isEnemySnakeCollision(point, excludeId = null) {
        for(const enemy of enemySnakes) {
            if (excludeId !== null && enemy.id === excludeId) continue;
            if (enemy.body.some(segment => segment.x === point.x && segment.y === point.y)) {
                return true;
            }
        }
        return false;
    }

    function isOccupied(point) {
        if (isPlayerSnakeCollision(point)) return true;
        if (isObstacleCollision(point)) return true;
        if (isEnemySnakeCollision(point)) return true;
        if (point.x === food.x && point.y === food.y) return true;
        if (blackHole && point.x === blackHole.x && point.y === blackHole.y) return true; 
        return false;
    }

    function generateRandomTile() {
        return {
            x: Math.floor(Math.random() * TILE_COUNT),
            y: Math.floor(Math.random() * TILE_COUNT)
        };
    }

    function placeFood() {
        let newFood;
        do {
            newFood = generateRandomTile();
        } while (isOccupied(newFood)); 
        food = newFood;
    }

    function placeBlackHole() {
        let newBlackHole;
        do {
            newBlackHole = generateRandomTile();
        } while (isOccupied(newBlackHole)); 
        blackHole = newBlackHole;
    }

    // --- OBSTACLE MANAGEMENT ---

    function generateObstacles(count) {
        for (let i = 0; i < count; i++) {
            let newObstacle;
            do {
                newObstacle = generateRandomTile();
            } while (isOccupied(newObstacle));
            obstacles.push(newObstacle);
        }
    }

    // --- ENEMY SNAKE MANAGEMENT ---

    function spawnEnemySnake() {
        if (enemySnakes.length >= MAX_ENEMY_SNACKS) return;

        let startPos;
        do {
            startPos = generateRandomTile();
        } while (isOccupied(startPos) || Math.abs(startPos.x - playerSnake[0].x) < 5 || Math.abs(startPos.y - playerSnake[0].y) < 5); // Don't spawn too close
        
        const directions = [{x: 1, y: 0}, {x: -1, y: 0}, {x: 0, y: 1}, {x: 0, y: -1}];
        const initialVel = directions[Math.floor(Math.random() * directions.length)];

        enemySnakes.push({
            id: Date.now() + Math.random(),
            body: [startPos, {x: startPos.x - initialVel.x, y: startPos.y - initialVel.y}],
            velocity: initialVel,
            color: `hsl(${Math.random() * 360}, 70%, 50%)`
        });
    }

    function moveEnemySnakes() {
        const playerHead = playerSnake[0];
        
        enemySnakes = enemySnakes.filter(enemy => {
            const head = enemy.body[0];
            let newVelocity = { ...enemy.velocity };
            let potentialHead = { x: head.x + newVelocity.x, y: head.y + newVelocity.y };

            // 1. AI Decision (70% chance to try and move toward player)
            if (Math.random() < ENEMY_AI_MOVE_CHANCE) {
                const diffX = playerHead.x - head.x;
                const diffY = playerHead.y - head.y;
                let desiredX = 0;
                let desiredY = 0;

                if (Math.abs(diffX) > Math.abs(diffY)) {
                    desiredX = diffX > 0 ? 1 : -1;
                } else if (Math.abs(diffY) > 0) {
                    desiredY = diffY > 0 ? 1 : -1;
                }
                
                // Only change direction if it's not immediately reversing
                if (desiredX !== -enemy.velocity.x || desiredY !== -enemy.velocity.y) {
                    if (desiredX !== 0) newVelocity = { x: desiredX, y: 0 };
                    else if (desiredY !== 0) newVelocity = { x: 0, y: desiredY };
                }
            }

            potentialHead = { x: head.x + newVelocity.x, y: head.y + newVelocity.y };

            // 2. Collision Check (Wall/Obstacle/Other Snake/Own Body)
            const isSelfCollision = enemy.body.slice(1).some(seg => seg.x === potentialHead.x && seg.y === potentialHead.y);
            
            // Check collision against walls or obstacles or other enemies
            if (potentialHead.x < 0 || potentialHead.x >= TILE_COUNT || 
                potentialHead.y < 0 || potentialHead.y >= TILE_COUNT || 
                isObstacleCollision(potentialHead) || 
                isEnemySnakeCollision(potentialHead, enemy.id) || 
                isSelfCollision) {
                
                // If collision detected, try a random non-reversing, non-colliding move
                const validMoves = [];
                const directions = [{x: 1, y: 0}, {x: -1, y: 0}, {x: 0, y: 1}, {x: 0, y: -1}];
                
                for (const dir of directions) {
                    if (dir.x === -enemy.velocity.x && dir.y === -enemy.velocity.y) continue; // Skip reverse
                    
                    const testHead = { x: head.x + dir.x, y: head.y + dir.y };
                    if (testHead.x >= 0 && testHead.x < TILE_COUNT && 
                        testHead.y >= 0 && testHead.y < TILE_COUNT && 
                        !isObstacleCollision(testHead) && 
                        !isEnemySnakeCollision(testHead, enemy.id) &&
                        !enemy.body.slice(1).some(seg => seg.x === testHead.x && seg.y === testHead.y)) {
                        validMoves.push(dir);
                    }
                }

                if (validMoves.length > 0) {
                    newVelocity = validMoves[Math.floor(Math.random() * validMoves.length)];
                    potentialHead = { x: head.x + newVelocity.x, y: head.y + newVelocity.y };
                } else {
                    // Stuck! Can't move. Skip this enemy's move this turn.
                    return true;
                }
            }

            // 3. Update Enemy State
            enemy.velocity = newVelocity;
            enemy.body.unshift(potentialHead);
            enemy.body.pop(); // Enemies do not grow, they maintain length 2

            return true; // Keep enemy
        });
    }

    // --- PLAYER MOVEMENT AND COLLISIONS ---

    function movePlayerSnake() {
        const head = { x: playerSnake[0].x + playerVelocity.x, y: playerSnake[0].y + playerVelocity.y };
        lastPlayerDirection = { ...playerVelocity };

        if (checkPlayerCollision(head)) {
            gameOver();
            return false;
        }

        playerSnake.unshift(head);

        // Check for food consumption
        if (head.x === food.x && head.y === food.y) {
            score++;
            scoreValue.textContent = score;

            // DIFFICULTY SCALING
            if (score === OBSTACLE_THRESHOLD_1) {
                generateObstacles(OBSTACLE_COUNT_1);
            }
            if (score === OBSTACLE_THRESHOLD_2) {
                generateObstacles(OBSTACLE_COUNT_2);
                spawnEnemySnake(); // Start spawning enemies at this level
            }
            if (score > ENEMY_SNAKE_THRESHOLD && score % 10 === 0 && enemySnakes.length < MAX_ENEMY_SNACKS) {
                spawnEnemySnake();
            }

            if (score <= MAX_SPEED_CAP_SCORE) {
                gameSpeed -= SPEED_INCREMENT;
                clearInterval(gameInterval);
                gameInterval = setInterval(gameLoop, gameSpeed);
            }
            
            // Check for black hole placement
            if (score >= APPLES_REQUIRED_FOR_WIN && blackHole === null) {
                placeBlackHole(); 
            }

            placeFood();
        } else {
            playerSnake.pop();
        }
        return true;
    }

    function checkPlayerCollision(head) {
        // 1. Wall Collision
        if (head.x < 0 || head.x >= TILE_COUNT || head.y < 0 || head.y >= TILE_COUNT) {
            return true;
        }
        
        // 2. Self Collision
        for (let i = 1; i < playerSnake.length; i++) {
            if (head.x === playerSnake[i].x && head.y === playerSnake[i].y) {
                return true;
            }
        }

        // 3. Obstacle Collision
        if (isObstacleCollision(head)) {
            return true;
        }

        // 4. Black Hole Collision (Win Condition Met)
        if (blackHole && head.x === blackHole.x && head.y === blackHole.y) {
            levelWon();
            return false;
        }

        // 5. Enemy Snake Collision (Head hits any enemy segment)
        for(const enemy of enemySnakes) {
            if (enemy.body.some(segment => segment.x === head.x && segment.y === head.y)) {
                return true;
            }
        }
        
        return false;
    }


    function gameEnd(message) {
        clearInterval(gameInterval);
        isGameOver = true;
        
        messageText.textContent = message;
        messageText.classList.add('game-over-text');
        finalScore.textContent = score;
        
        finalScoreDisplay.style.display = 'block'; 
        nameInputGroup.style.display = 'flex';
        restartButton.textContent = 'Save Score & Restart';
        messageBox.style.display = 'flex';
        playerNameInput.focus();
        
        // NEW: Show leaderboard when game ends
        toggleLeaderboardVisibility(true);
    }

    function levelWon() {
        gameEnd('LEVEL COMPLETE!');
    }

    function gameOver() {
        gameEnd('GAME OVER!');
    }

    function gameLoop() {
        if (!isGameStarted || isGameOver) {
            draw();
            return;
        }

        // 1. Move Enemy Snakes before the player
        moveEnemySnakes();

        // 2. Move Player Snake
        if (movePlayerSnake()) {
            draw();
        }
    }

    // --- DRAWING FUNCTIONS (Unchanged) ---

    function clearScreen() {
        ctx.fillStyle = '#0d1117'; 
        ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    function drawSnake() {
        // Player Snake (Pink/White)
        ctx.strokeStyle = '#ffffff'; 
        playerSnake.forEach((segment, index) => {
            ctx.fillStyle = index === 0 ? '#ffffff' : '#ff0077';
            ctx.fillRect(segment.x * tileSize, segment.y * tileSize, tileSize - 1, tileSize - 1);
            ctx.strokeRect(segment.x * tileSize, segment.y * tileSize, tileSize - 1, tileSize - 1);
        });

        // Enemy Snakes (Random Color/Black)
        enemySnakes.forEach(enemy => {
            enemy.body.forEach((segment, index) => {
                ctx.fillStyle = index === 0 ? '#ff0077' : enemy.color; // Enemy head is pink too for high visibility
                ctx.fillRect(segment.x * tileSize, segment.y * tileSize, tileSize - 1, tileSize - 1);
                ctx.strokeStyle = '#000000';
                ctx.strokeRect(segment.x * tileSize, segment.y * tileSize, tileSize - 1, tileSize - 1);
            });
        });
    }

    function drawFood() {
        ctx.shadowBlur = 0;
        ctx.font = `${tileSize * 0.9}px sans-serif`; 
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const centerX = food.x * tileSize + tileSize / 2;
        const centerY = food.y * tileSize + tileSize / 2;
        ctx.fillText('ðŸŽ', centerX, centerY + (tileSize * 0.05)); 
    }

    function drawObstacles() {
        ctx.fillStyle = '#44475a'; // Dark gray/purple
        ctx.strokeStyle = '#282a36';
        obstacles.forEach(obs => {
            ctx.fillRect(obs.x * tileSize, obs.y * tileSize, tileSize - 1, tileSize - 1);
            ctx.strokeRect(obs.x * tileSize, obs.y * tileSize, tileSize - 1, tileSize - 1);
        });
    }

    function drawBlackHole() {
        if (!blackHole) return;
        const centerX = blackHole.x * tileSize + tileSize / 2;
        const centerY = blackHole.y * tileSize + tileSize / 2;
        const radius = tileSize / 2;
        
        ctx.shadowBlur = 15;
        ctx.shadowColor = '#00ffff'; // Cyan glow

        ctx.fillStyle = '#000000'; 
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius * 0.9, 0, 2 * Math.PI);
        ctx.fill();

        ctx.fillStyle = '#1c1e21'; 
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius * 0.7, 0, 2 * Math.PI);
        ctx.fill();

        ctx.strokeStyle = '#00ffff';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius * 0.8, 0, Math.PI / 2);
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius * 0.8, Math.PI, 3 * Math.PI / 2);
        ctx.stroke();

        ctx.shadowBlur = 0;
        ctx.shadowColor = 'transparent';
    }
    
    function draw() {
        clearScreen();
        drawFood();
        drawObstacles();
        drawBlackHole(); 
        drawSnake();
    }

    // --- INPUT HANDLERS (Unchanged) ---

    function setDirection(newX, newY) {
        // Prevents reversing direction immediately
        if (lastPlayerDirection.x === -newX && lastPlayerDirection.y === -newY) {
            return;
        }

        playerVelocity.x = newX;
        playerVelocity.y = newY;
        
        if (!isGameStarted && !isGameOver) {
            isGameStarted = true;
            messageBox.style.display = 'none';
            // Hide leaderboard when the game officially starts
            toggleLeaderboardVisibility(false); 
        }
    }

    document.addEventListener('keydown', (e) => {
        if (messageBox.style.display === 'flex' && isGameStarted) return;
        if (isGameOver && (e.key === 'ArrowUp' || e.key === 'ArrowDown' || e.key === 'ArrowLeft' || e.key === 'ArrowRight')) return; 

        switch (e.key) {
            case 'ArrowUp':
                e.preventDefault();
                setDirection(0, -1);
                break;
            case 'ArrowDown':
                e.preventDefault();
                setDirection(0, 1);
                break;
            case 'ArrowLeft':
                e.preventDefault();
                setDirection(-1, 0);
                break;
            case 'ArrowRight':
                e.preventDefault();
                setDirection(1, 0);
                break;
        }
    });

    // 1. SWIPE CONTROLS IMPLEMENTATION
    
    canvas.addEventListener('touchstart', (e) => {
        if (isGameOver) return;
        const touch = e.touches[0];
        touchStartX = touch.clientX;
        touchStartY = touch.clientY;
    }, { passive: true });

    canvas.addEventListener('touchend', (e) => {
        if (isGameOver) return;
        
        const touchEnd = e.changedTouches[0];
        const deltaX = touchEnd.clientX - touchStartX;
        const deltaY = touchEnd.clientY - touchStartY;

        if (Math.abs(deltaX) < SWIPE_THRESHOLD && Math.abs(deltaY) < SWIPE_THRESHOLD) {
            return;
        }

        if (Math.abs(deltaX) > Math.abs(deltaY)) {
            setDirection(deltaX > 0 ? 1 : -1, 0);
        } else {
            setDirection(0, deltaY > 0 ? 1 : -1);
        }
    }, { passive: true });


    // 2. D-PAD BUTTON FIX 
    controls.addEventListener('click', (e) => {
        if (e.target.tagName === 'BUTTON') {
            e.preventDefault();
            if (isGameOver) return;

            const direction = e.target.getAttribute('data-direction');

            switch (direction) {
                case 'up':
                    setDirection(0, -1);
                    break;
                case 'down':
                    setDirection(0, 1);
                    break;
                case 'left':
                    setDirection(-1, 0);
                    break;
                case 'right':
                    setDirection(1, 0);
                    break;
            }
        }
    });

    // Combined Start/Restart/Save button handler
    restartButton.addEventListener('click', () => {
        if (isGameOver) {
            // State 1: GAME OVER -> Save Score & Restart
            const name = playerNameInput.value.substring(0, 10).toUpperCase();
            saveScore(name, score);
            initializeGame();
        } else if (!isGameStarted) {
            // State 2: INITIAL START -> Begin Game via the button
            isGameStarted = true;
            messageBox.style.display = 'none';
            toggleLeaderboardVisibility(false); // Hide it when starting
            // Set a default starting direction (e.g., right)
            setDirection(1, 0); 
        }
    });

    // --- RESIZE AND START ---

    function resizeCanvas() {
        const gameContainer = canvas.parentElement;
        const availableWidth = gameContainer.clientWidth - 40;
        let size = Math.min(availableWidth, 400); 
        
        canvas.width = size;
        canvas.height = size;
        
        tileSize = canvas.width / TILE_COUNT;
        
        // When resizing, re-check visibility (it might move from mobile to desktop view)
        toggleLeaderboardVisibility(isGameOver || !isGameStarted);

        draw();
    }

    window.onload = function() {
        setupFirebase();
        resizeCanvas();
        initializeGame();
    }
    
    window.addEventListener('resize', resizeCanvas);
</script>
</body>
</html>
